.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man v6.0.2 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Required to disable full justification in groff 1.23.0.
.if n .ds AD l
.\" ========================================================================
.\"
.IX Title "Read 3"
.TH Read 3 2025-01-06 "perl v5.40.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
Spreadsheet::Read \- Read the data from a spreadsheet
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 9
\& use Spreadsheet::Read;
\& my $book  = ReadData ("test.csv", sep => ";");
\& my $book  = ReadData ("test.sxc");
\& my $book  = ReadData ("test.ods");
\& my $book  = ReadData ("test.xls");
\& my $book  = ReadData ("test.xlsx");
\& my $book  = ReadData ("test.xlsm");
\& my $book  = ReadData ("test.gnumeric");
\& my $book  = ReadData ($fh, parser => "xls");
\&
\& Spreadsheet::Read::add ($book, "sheet.csv");
\&
\& my $sheet = $book\->[1];             # first datasheet
\& my $cell  = $book\->[1]{A3};         # content of field A3 of sheet 1
\& my $cell  = $book\->[1]{cell}[1][3]; # same, unformatted
\&
\& # OO API
\& my $book = Spreadsheet::Read\->new ("file.csv");
\& my $sheet = $book\->sheet (1);
\& my $cell  = $sheet\->cell ("A3");
\& my $cell  = $sheet\->cell (1, 3);
\&
\& $book\->add ("test.xls");
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Spreadsheet::Read tries to transparently read *any* spreadsheet and
return its content in a universal manner independent of the parsing
module that does the actual spreadsheet scanning.
.PP
The parser has to be available and is not provided by this module.
.SS "Supported spreadsheets"
.IX Subsection "Supported spreadsheets"
\fIOpenOffice and LibreOffice (\fR\f(CI\*(C`ODS\*(C'\fR\fI and \fR\f(CI\*(C`SXC\*(C'\fR\fI)\fR
.IX Subsection "OpenOffice and LibreOffice (ODS and SXC)"
.PP
For OpenOffice and/or LibreOffice this module uses
Spreadsheet::ParseODS <https://metacpan.org/pod/Spreadsheet::ParseODS> or
Spreadsheet::ReadSXC <https://metacpan.org/release/Spreadsheet-ReadSXC>
.PP
\fIMicrosoft Excel (\fR\f(CI\*(C`XLSX\*(C'\fR\fI and \fR\f(CI\*(C`XLS\*(C'\fR\fI)\fR
.IX Subsection "Microsoft Excel (XLSX and XLS)"
.PP
For Microsoft Excel this module uses
Spreadsheet::ParseExcel <https://metacpan.org/release/Spreadsheet-ParseExcel>,
Spreadsheet::ParseXLSX <https://metacpan.org/release/Spreadsheet-ParseXLSX>,
Excel::ValueReader::XLSX <https://metacpan.org/release/Excel-ValueReader-XLSX>, or
Spreadsheet::XLSX <https://metacpan.org/release/Spreadsheet-XLSX> (strongly
discouraged).
.PP
\fICSV (\fR\f(CI\*(C`CSV\*(C'\fR\fI)\fR
.IX Subsection "CSV (CSV)"
.PP
For CSV this module uses Text::CSV_XS <https://metacpan.org/release/Text-CSV_XS>
or Text::CSV_PP <https://metacpan.org/release/Text-CSV>.
.PP
\fIGnumeric (\fR\f(CI\*(C`gnumeric\*(C'\fR\fI)\fR
.IX Subsection "Gnumeric (gnumeric)"
.PP
For Gnumeric this module uses
Spreadsheet::ReadGnumeric <https://metacpan.org/release/Spreadsheet-ReadGnumeric>.
.PP
\fISquirrelCalc (\fR\f(CI\*(C`sc\*(C'\fR\fI)\fR
.IX Subsection "SquirrelCalc (sc)"
.PP
For SquirrelCalc there is a very simplistic built\-in parser
.SS "Data structure"
.IX Subsection "Data structure"
The data is returned as an array reference:
.PP
.Vb 10
\&  $book = [
\&      # Entry 0 is the overall control hash
\&      { sheets  => 2,
\&        sheet   => {
\&          "Sheet 1" => 1,
\&          "Sheet 2" => 2,
\&          },
\&        parsers => [ {
\&          type      => "xls",
\&          parser    => "Spreadsheet::ParseExcel",
\&          version   => 0.59,
\&          }],
\&        error   => undef,
\&        },
\&      # Entry 1 is the first sheet
\&      { parser  => 0,
\&        label   => "Sheet 1",
\&        maxrow  => 2,
\&        maxcol  => 4,
\&        cell    => [ undef,
\&          [ undef, 1 ],
\&          [ undef, undef, undef, undef, undef, "Nugget" ],
\&          ],
\&        attr    => [],
\&        merged  => [],
\&        active  => 1,
\&        hidden  => 0,
\&        A1      => 1,
\&        B5      => "Nugget",
\&        },
\&      # Entry 2 is the second sheet
\&      { parser  => 0,
\&        label   => "Sheet 2",
\&        :
\&        :
.Ve
.PP
To keep as close contact to spreadsheet users, row and column 1 have
index 1 too in the \f(CW\*(C`cell\*(C'\fR element of the sheet hash, so cell "A1" is
the same as \f(CW\*(C`cell\*(C'\fR [1, 1] (column first). To switch between the two,
there are helper functions available: \f(CW\*(C`cell2cr ()\*(C'\fR, \f(CW\*(C`cr2cell ()\*(C'\fR,
and \f(CW\*(C`col2label ()\*(C'\fR.
.PP
The \f(CW\*(C`cell\*(C'\fR hash entry contains unformatted data, while the hash entries
with the traditional labels contain the formatted values (if applicable).
.PP
The control hash (the first entry in the returned array ref), contains
some spreadsheet meta\-data. The entry \f(CW\*(C`sheet\*(C'\fR is there to be able to find
the sheets when accessing them by name:
.PP
.Vb 1
\&  my %sheet2 = %{$book\->[$book\->[0]{sheet}{"Sheet 2"}]};
.Ve
.SS "Formatted vs Unformatted"
.IX Subsection "Formatted vs Unformatted"
The difference between formatted and unformatted cells is that the (optional)
format is applied to the cell or not. This part is \fBcompletely\fR implemented
on the parser side. Spreadsheet::Read just makes both available if these are
supported. Options provide means to disable either. If the parser does not
provide formatted cells \- like CSV \- both values are equal.
.PP
To show what this implies:
.PP
.Vb 1
\& use Spreadsheet::Read;
\&
\& my $file     = "files/example.xlsx";
\& my $workbook = Spreadsheet::Read\->new ($file);
\&
\& my $info     = $workbook\->[0];
\& say "Parsed $file with $info\->{parser}\-$info\->{version}";
\&
\& my $sheet    = $workbook\->sheet (1);
\&
\& say join "\et" => "Formatted:",   $sheet\->row     (1);
\& say join "\et" => "Unformatted:", $sheet\->cellrow (1);
.Ve
.PP
Might return very different results depending one the underlying parser (and
its version):
.PP
.Vb 3
\& Parsed files/example.xlsx with Spreadsheet::ParseXLSX\-0.27
\& Formatted:      8\-Aug   Foo & Barr < Quux
\& Unformatted:    39668   Foo & Barr < Quux
\&
\& Parsed files/example.xlsx with Spreadsheet::XLSX\-0.15
\& Formatted:      39668   Foo &amp; Barr &lt; Quux
\& Unformatted:    39668   Foo &amp; Barr &lt; Quux
.Ve
.SS "Functions and methods"
.IX Subsection "Functions and methods"
\fInew\fR
.IX Subsection "new"
.PP
.Vb 1
\& my $book = Spreadsheet::Read\->new (...) or die $@;
.Ve
.PP
All options accepted by ReadData are accepted by new.
.PP
With no arguments at all, \f(CW$book\fR will be an object where sheets can be added
using \f(CW\*(C`add\*(C'\fR
.PP
.Vb 3
\& my $book = Spreadsheet::Read\->new ();
\& $book\->add ("file.csv");
\& $book\->add ("file.cslx");
.Ve
.PP
\fIReadData\fR
.IX Subsection "ReadData"
.PP
.Vb 1
\& my $book = ReadData ($source [, option => value [, ... ]]);
\&
\& my $book = ReadData ("file.csv", sep => \*(Aq,\*(Aq, quote => \*(Aq"\*(Aq);
\&
\& my $book = ReadData ("file.xls", dtfmt => "yyyy\-mm\-dd");
\&
\& my $book = ReadData ("file.ods");
\&
\& my $book = ReadData ("file.sxc");
\&
\& my $book = ReadData ("content.xml");
\&
\& my $book = ReadData ($content);
\&
\& my $book = ReadData ($content,  parser => "xlsx");
\&
\& my $book = ReadData ($fh,       parser => "xlsx");
\&
\& my $book = ReadData (\e$content, parser => "xlsx");
.Ve
.PP
Tries to convert the given file, string, or stream to the data structure
described above.
.PP
Processing Excel data from a stream or content is supported through a
File::Temp <https://metacpan.org/release/File-Temp> temporary file or
IO::Scalar <https://metacpan.org/release/IO-stringy> when available.
.PP
Spreadsheet::ReadSXC <https://metacpan.org/release/Spreadsheet-ReadSXC>
does preserve sheet order as of version 0.20.
.PP
Choosing between \f(CW$content\fR and \f(CW\*(C`\e\e$content\*(C'\fR (with or without passing
the desired \f(CW\*(C`parser\*(C'\fR option) may be depending on trial and terror.
\&\f(CW\*(C`ReadData\*(C'\fR does try to determine parser type on content if needed, but
not all combinations are checked, and not all signatures are builtin.
.PP
Currently supported options are:
.IP parser 2
.IX Xref "parser"
.IX Item "parser"
Force the data to be parsed by a specific format. Possible values are
\&\f(CW\*(C`csv\*(C'\fR, \f(CW\*(C`prl\*(C'\fR (or \f(CW\*(C`perl\*(C'\fR), \f(CW\*(C`sc\*(C'\fR (or \f(CW\*(C`squirrelcalc\*(C'\fR), \f(CW\*(C`sxc\*(C'\fR (or \f(CW\*(C`oo\*(C'\fR,
\&\f(CW\*(C`ods\*(C'\fR, \f(CW\*(C`openoffice\*(C'\fR, \f(CW\*(C`libreoffice\*(C'\fR) \f(CW\*(C`xls\*(C'\fR (or \f(CW\*(C`excel\*(C'\fR), and \f(CW\*(C`xlsx\*(C'\fR
(or \f(CW\*(C`excel2007\*(C'\fR).
.Sp
When parsing streams, instead of files, it is highly recommended to pass
this option.
.Sp
Spreadsheet::Read supports several underlying parsers per spreadsheet
type. It will try those from most favored to least favored. When you
have a good reason to prefer a different parser, you can set that in
environment variables. The other options then will not be tested for:
.Sp
.Vb 1
\& env SPREADSHEET_READ_CSV=Text::CSV_PP ...
.Ve
.Sp
You can also directly pass the required backend, forcing the matching
type, but this excludes version checking.
.Sp
.Vb 3
\& # Checks for minimal version
\& BEGIN { $ENV{SPREADSHEET_READ_CSV} = "Text::CSV_PP" }
\& my $book = ReadData ("test.csv", parser => "csv");
\&
\& vs
\&
\& # NO check for minimal version
\& my $book = ReadData ("test.csv", parser => "Text::CSV_PP");
.Ve
.IP cells 2
.IX Xref "cells"
.IX Item "cells"
Control the generation of named cells ("\f(CW\*(C`A1\*(C'\fR" etc). Default is true.
.IP rc 2
.IX Item "rc"
Control the generation of the {cell}[c][r] entries. Default is true.
.IP attr 2
.IX Item "attr"
Control the generation of the {attr}[c][r] entries. Default is false.
See "Cell Attributes" below.
.IP clip 2
.IX Item "clip"
If set, \f(CW\*(C`ReadData\*(C'\fR will remove all trailing rows and columns
per sheet that have no data, where no data means only undefined or empty
cells (after optional stripping). If a sheet has no data at all, the sheet
will be skipped entirely when this attribute is true.
.IP trim 2
.IX Item "trim"
.PD 0
.IP strip 2
.IX Item "strip"
.PD
If set, \f(CW\*(C`ReadData\*(C'\fR will remove trailing\- and/or
leading\-whitespace from every field.
.Sp
.Vb 6
\&  strip  leading  strailing
\&  \-\-\-\-\-  \-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-
\&    0      n/a      n/a
\&    1     strip     n/a
\&    2      n/a     strip
\&    3     strip    strip
.Ve
.Sp
\&\f(CW\*(C`trim\*(C'\fR and \f(CW\*(C`strip\*(C'\fR are aliases. If passed both, \f(CW\*(C`trim\*(C'\fR is ignored
because of backward compatibility.
.IP transpose 2
.IX Item "transpose"
.PD 0
.IP pivot 2
.IX Item "pivot"
.PD
Swap all rows and columns.
.Sp
When a sheet contains data like
.Sp
.Vb 3
\&  A1  B1  C1      E1
\&  A2      C2  D2
\&  A3  B3  C3  D3  E3
.Ve
.Sp
using \f(CW\*(C`transpose\*(C'\fR or \f(CW\*(C`pivot\*(C'\fR will return the sheet data as
.Sp
.Vb 5
\&  A1  A2  A3
\&  B1      B3
\&  C1  C2  C3
\&      D2  D3
\&  E1      E3
.Ve
.Sp
\&\f(CW\*(C`transpose\*(C'\fR and \f(CW\*(C`pivot\*(C'\fR are aliases. If passed both, \f(CW\*(C`transpose\*(C'\fR is
ignored because of backward compatibility.
.IP sep 2
.IX Item "sep"
Set separator for CSV. Default is comma \f(CW\*(C`,\*(C'\fR.
.IP quote 2
.IX Item "quote"
Set quote character for CSV. Default is \f(CW\*(C`"\*(C'\fR.
.IP dtfmt 2
.IX Item "dtfmt"
Set the format for MS\-Excel date fields that are set to use the default
date format. The default format in Excel is "\f(CW\*(C`m\-d\-yy\*(C'\fR", which is both
not year 2000 safe, nor very useful. The default is now "\f(CW\*(C`yyyy\-mm\-dd\*(C'\fR",
which is more ISO\-like.
.Sp
Note that date formatting in MS\-Excel is not reliable at all, as it will
store/replace/change the date field separator in already stored formats
if you change your locale settings. So the above mentioned default can
be either "\f(CW\*(C`m\-d\-yy\*(C'\fR" OR "\f(CW\*(C`m/d/yy\*(C'\fR" depending on what that specific
character happened to be at the time the user saved the file.
.IP merge 2
.IX Item "merge"
Copy content to all cells in merged areas.
.Sp
If supported, this will copy formatted and unformatted values from the
top\-left cell of a merged area to all other cells in the area.
.IP debug 2
.IX Item "debug"
Enable some diagnostic messages to STDERR.
.Sp
The value determines how much diagnostics are dumped (using
Data::Peek <https://metacpan.org/release/Data-Peek>).  A value of \f(CW9\fR
and higher will dump the entire structure from the back\-end parser.
.IP passwd 2
.IX Item "passwd"
Use this password to decrypt password protected spreadsheet.
.Sp
Currently only supports Excel.
.PP
All other attributes/options will be passed to the underlying parser if
that parser supports attributes.
.PP
\fIcol2label\fR
.IX Subsection "col2label"
.PP
.Vb 1
\& my $col_id = col2label (col);
\&
\& my $col_id = $book\->col2label (col);  # OO
.Ve
.PP
\&\f(CW\*(C`col2label ()\*(C'\fR converts a \f(CW\*(C`(column)\*(C'\fR (1 based) to the letters used in the
traditional cell notation:
.PP
.Vb 2
\&  my $id = col2label ( 4); # $id now "D"
\&  my $id = col2label (28); # $id now "AB"
.Ve
.PP
\fIcr2cell\fR
.IX Subsection "cr2cell"
.PP
.Vb 1
\& my $cell = cr2cell (col, row);
\&
\& my $cell = $book\->cr2cell (col, row);  # OO
.Ve
.PP
\&\f(CW\*(C`cr2cell ()\*(C'\fR converts a \f(CW\*(C`(column, row)\*(C'\fR pair (1 based) to the
traditional cell notation:
.PP
.Vb 2
\&  my $cell = cr2cell ( 4, 14); # $cell now "D14"
\&  my $cell = cr2cell (28,  4); # $cell now "AB4"
.Ve
.PP
\fIcell2cr\fR
.IX Subsection "cell2cr"
.PP
.Vb 1
\& my ($col, $row) = cell2cr ($cell);
\&
\& my ($col, $row) = $book\->cell2cr ($cell);  # OO
.Ve
.PP
\&\f(CW\*(C`cell2cr ()\*(C'\fR converts traditional cell notation to a \f(CW\*(C`(column, row)\*(C'\fR
pair (1 based):
.PP
.Vb 2
\&  my ($col, $row) = cell2cr ("D14"); # returns ( 4, 14)
\&  my ($col, $row) = cell2cr ("AB4"); # returns (28,  4)
.Ve
.PP
\fIrow\fR
.IX Subsection "row"
.PP
.Vb 1
\& my @row = row ($sheet, $row)
\&
\& my @row = Spreadsheet::Read::row ($book\->[1], 3);
\&
\& my @row = $book\->row ($sheet, $row); # OO
.Ve
.PP
Get full row of formatted values (like \f(CW\*(C`$sheet\->{A3} .. $sheet\->{G3}\*(C'\fR)
.PP
Note that the indexes in the returned list are 0\-based.
.PP
\&\f(CW\*(C`row ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified.
.PP
See also the \f(CW\*(C`row ()\*(C'\fR method on sheets.
.PP
\fIcellrow\fR
.IX Subsection "cellrow"
.PP
.Vb 1
\& my @row = cellrow ($sheet, $row);
\&
\& my @row = Spreadsheet::Read::cellrow ($book\->[1], 3);
\&
\& my @row = $book\->cellrow ($sheet, $row); # OO
.Ve
.PP
Get full row of unformatted values (like \f(CW\*(C`$sheet\->{cell}[1][3] .. $sheet\->{cell}[7][3]\*(C'\fR)
.PP
Note that the indexes in the returned list are 0\-based.
.PP
\&\f(CW\*(C`cellrow ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified or as method call.
.PP
See also the \f(CW\*(C`cellrow ()\*(C'\fR method on sheets.
.PP
\fIrows\fR
.IX Subsection "rows"
.PP
.Vb 1
\& my @rows = rows ($sheet);
\&
\& my @rows = Spreadsheet::Read::rows ($book\->[1]);
\&
\& my @rows = $book\->rows (1); # OO
.Ve
.PP
Convert \f(CW\*(C`{cell}\*(C'\fR\*(Aqs \f(CW\*(C`[column][row]\*(C'\fR to a \f(CW\*(C`[row][column]\*(C'\fR list.
.PP
Note that the indexes in the returned list are 0\-based, where the
index in the \f(CW\*(C`{cell}\*(C'\fR entry is 1\-based.
.PP
\&\f(CW\*(C`rows ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified.
.PP
\fIparses\fR
.IX Subsection "parses"
.PP
.Vb 1
\& parses ($format);
\&
\& Spreadsheet::Read::parses ("CSV");
\&
\& $book\->parses ("CSV"); # OO
.Ve
.PP
\&\f(CW\*(C`parses ()\*(C'\fR returns Spreadsheet::Read\*(Aqs capability to parse the
required format or \f(CW0\fR if it does not. \f(CW\*(C`ReadData\*(C'\fR
will pick its preferred parser for that format unless overruled.
See \f(CW\*(C`parser\*(C'\fR.
.PP
\&\f(CW\*(C`parses ()\*(C'\fR is not imported by default, so either specify it in
the use argument list, or call it fully qualified.
.PP
If \f(CW$format\fR is false (\f(CW\*(C`undef\*(C'\fR, \f(CW""\fR, or \f(CW0\fR), \f(CW\*(C`parses ()\*(C'\fR
will return a sorted list of supported types.
.PP
.Vb 1
\& @my types = parses ("");   # e.g: csv, ods, sc, sxc, xls, xlsx
.Ve
.PP
\fIparsers\fR
.IX Subsection "parsers"
.PP
.Vb 1
\& my @p = parsers ();
.Ve
.PP
\&\f(CW\*(C`parsers ()\*(C'\fR returns a list of hashrefs with information about
supported parsers, each giving information about the parser, its
versions and if it will be used as default parser for the given
type, like:
.PP
.Vb 6
\& { ext => "csv",            # extension or type
\&   mod => "Text::CSV_XS",   # parser module
\&   min => "0.71",           # module required  version
\&   vsn => "1.45",           # module installed version
\&   def => "*",              # is default for ext
\&   }
.Ve
.PP
As the modules are actually loaded to get their version, do only
use this to analyse prerequisites.
.PP
\fIVersion\fR
.IX Subsection "Version"
.PP
.Vb 1
\& my $v = Version ()
\&
\& my $v = Spreadsheet::Read::Version ()
\&
\& my $v = Spreadsheet::Read\->VERSION;
\&
\& my $v = $book\->Version (); # OO
.Ve
.PP
Returns the current version of Spreadsheet::Read.
.PP
\&\f(CW\*(C`Version ()\*(C'\fR is not imported by default, so either specify it in the
use argument list, or call it fully qualified.
.PP
This function returns exactly the same as \f(CW\*(C`Spreadsheet::Read\->VERSION\*(C'\fR
returns and is only kept for backward compatibility reasons.
.PP
\fIsheets\fR
.IX Subsection "sheets"
.PP
.Vb 2
\& my $sheets = $book\->sheets; # OO
\& my @sheets = $book\->sheets; # OO
.Ve
.PP
In scalar context return the number of sheets in the book.
.PP
In list context return the labels of the sheets in the book. This list only
returns known unique labels in sorted order. Sheets could have no label or
there can be more sheets with the same label (depends on the spreadsheet
format and the parser used).
.PP
\fIsheet\fR
.IX Subsection "sheet"
.PP
.Vb 2
\& my $sheet = $book\->sheet (1);     # OO
\& my $sheet = $book\->sheet ("Foo"); # OO
.Ve
.PP
Return the numbered or named sheet out of the book. Will return \f(CW\*(C`undef\*(C'\fR if
there is no match. Will not work for sheets \fInamed\fR with a number between 1
and the number of sheets in the book.
.PP
With named sheets will first try to use the list of sheet\-labels as stored in
the control structure. If no match is found, it will scan the actual labels
of the sheets. In that case, it will return the first matching sheet.
.PP
If defined, the returned sheet will be of class \f(CW\*(C`Spreadsheet::Read::Sheet\*(C'\fR.
.PP
\fIadd\fR
.IX Subsection "add"
.PP
.Vb 2
\& my $book = ReadData ("file.csv");
\& Spreadsheet::Read::add ($book, "file.xlsx");
\&
\& my $book = Spreadsheet::Read\->new ("file.csv");
\& $book\->add ("file.xlsx"); # OO
.Ve
.SS "Methods on sheets"
.IX Subsection "Methods on sheets"
\fImaxcol\fR
.IX Subsection "maxcol"
.PP
.Vb 1
\& my $col = $sheet\->maxcol;
.Ve
.PP
Return the index of the last in\-use column in the sheet. This index is 1\-based.
.PP
\fImaxrow\fR
.IX Subsection "maxrow"
.PP
.Vb 1
\& my $row = $sheet\->maxrow;
.Ve
.PP
Return the index of the last in\-use row in the sheet. This index is 1\-based.
.PP
\fIcell\fR
.IX Subsection "cell"
.PP
.Vb 2
\& my $cell = $sheet\->cell ("A3");
\& my $cell = $sheet\->cell (1, 3);
.Ve
.PP
Return the value for a cell. Using tags will return the formatted value,
using column and row will return unformatted value.
.PP
\fIattr\fR
.IX Subsection "attr"
.PP
.Vb 2
\& my $cell = $sheet\->attr ("A3");
\& my $cell = $sheet\->attr (1, 3);
.Ve
.PP
Return the attributes of a cell. Only valid if attributes are enabled through
option \f(CW\*(C`attr\*(C'\fR.
.PP
\fIcol2label\fR
.IX Subsection "col2label"
.PP
.Vb 1
\& my $col_id = $sheet\->col2label (col);
.Ve
.PP
\&\f(CW\*(C`col2label ()\*(C'\fR converts a \f(CW\*(C`(column)\*(C'\fR (1 based) to the letters used in the
traditional cell notation:
.PP
.Vb 2
\&  my $id = $sheet\->col2label ( 4); # $id now "D"
\&  my $id = $sheet\->col2label (28); # $id now "AB"
.Ve
.PP
\fIcr2cell\fR
.IX Subsection "cr2cell"
.PP
.Vb 1
\& my $cell = $sheet\->cr2cell (col, row);
.Ve
.PP
\&\f(CW\*(C`cr2cell ()\*(C'\fR converts a \f(CW\*(C`(column, row)\*(C'\fR pair (1 based) to the
traditional cell notation:
.PP
.Vb 2
\&  my $cell = $sheet\->cr2cell ( 4, 14); # $cell now "D14"
\&  my $cell = $sheet\->cr2cell (28,  4); # $cell now "AB4"
.Ve
.PP
\fIcell2cr\fR
.IX Subsection "cell2cr"
.PP
.Vb 1
\& my ($col, $row) = $sheet\->cell2cr ($cell);
.Ve
.PP
\&\f(CW\*(C`cell2cr ()\*(C'\fR converts traditional cell notation to a \f(CW\*(C`(column, row)\*(C'\fR
pair (1 based):
.PP
.Vb 2
\&  my ($col, $row) = $sheet\->cell2cr ("D14"); # returns ( 4, 14)
\&  my ($col, $row) = $sheet\->cell2cr ("AB4"); # returns (28,  4)
.Ve
.PP
\fIcol\fR
.IX Subsection "col"
.PP
.Vb 1
\& my @col = $sheet\->column ($col);
.Ve
.PP
Get full column of formatted values (like \f(CW\*(C`$sheet\->{C1} .. $sheet\->{C9}\*(C'\fR)
.PP
Note that the indexes in the returned list are 0\-based.
.PP
\fIcellcolumn\fR
.IX Subsection "cellcolumn"
.PP
.Vb 1
\& my @col = $sheet\->cellcolumn ($col);
.Ve
.PP
Get full column of unformatted values (like \f(CW\*(C`$sheet\->{cell}[3][1] .. $sheet\->{cell}[3][9]\*(C'\fR)
.PP
Note that the indexes in the returned list are 0\-based.
.PP
\fIrow\fR
.IX Subsection "row"
.PP
.Vb 1
\& my @row = $sheet\->row ($row);
.Ve
.PP
Get full row of formatted values (like \f(CW\*(C`$sheet\->{A3} .. $sheet\->{G3}\*(C'\fR)
.PP
Note that the indexes in the returned list are 0\-based.
.PP
\fIcellrow\fR
.IX Subsection "cellrow"
.PP
.Vb 1
\& my @row = $sheet\->cellrow ($row);
.Ve
.PP
Get full row of unformatted values (like \f(CW\*(C`$sheet\->{cell}[1][3] .. $sheet\->{cell}[7][3]\*(C'\fR)
.PP
Note that the indexes in the returned list are 0\-based.
.PP
\fIrows\fR
.IX Subsection "rows"
.PP
.Vb 1
\& my @rows = $sheet\->rows ();
.Ve
.PP
Convert \f(CW\*(C`{cell}\*(C'\fR\*(Aqs \f(CW\*(C`[column][row]\*(C'\fR to a \f(CW\*(C`[row][column]\*(C'\fR list.
.PP
Note that the indexes in the returned list are 0\-based, where the
index in the \f(CW\*(C`{cell}\*(C'\fR entry is 1\-based.
.PP
\fImerged_from\fR
.IX Subsection "merged_from"
.PP
.Vb 2
\& my $top_left = $sheet\->merged_from ("C2");
\& my $top_left = $sheet\->merged_from (3, 2);
.Ve
.PP
If the parser supports merged areas, this method will return the label of the
top\-left cell in the merged area the requested cell is part of.
.PP
If the requested ID is valid and withing the sheet cell range, but not part of
a merged area, it will return \f(CW""\fR.
.PP
If the ID is not valid or out of range, it returns \f(CW\*(C`undef\*(C'\fR.
.PP
See Merged cells for more details.
.PP
\fIlabel\fR
.IX Subsection "label"
.PP
.Vb 2
\& my $label = $sheet\->label;
\& $sheet\->label ("New sheet label");
.Ve
.PP
Set a new label to a sheet. Note that the index in the control structure will
\&\fINOT\fR be updated.
.PP
\fIactive\fR
.IX Subsection "active"
.PP
.Vb 1
\& my $sheet_is_active = $sheet\->active;
.Ve
.PP
Returns 1 if the selected sheet is active, otherwise returns 0.
.PP
Currently only works on XLS (as of Spreadsheed::ParseExcel\-0.61).
CSV is always active.
.PP
\fIhidden\fR
.IX Subsection "hidden"
.PP
.Vb 1
\& my $sheet_is_hidden = $sheet\->hidden;
.Ve
.PP
Returns 1 if the selected sheet is hidden, otherwise returns 0.
.PP
Fully depends on the backend supporting this.  CSV and SC are never hidden.
.SS "Using CSV"
.IX Subsection "Using CSV"
In case of CSV parsing, \f(CW\*(C`ReadData\*(C'\fR will use the first line of
the file to auto\-detect the separation character if the first argument is a
file and both \f(CW\*(C`sep\*(C'\fR and \f(CW\*(C`quote\*(C'\fR are not passed as attributes.
Text::CSV_XS <https://metacpan.org/release/Text-CSV_XS> (or
Text::CSV_PP <https://metacpan.org/release/Text-CSV>) is able to
automatically detect and use \f(CW\*(C`\er\*(C'\fR line endings.
.PP
CSV can parse streams too, but be sure to pass \f(CW\*(C`sep\*(C'\fR and/or \f(CW\*(C`quote\*(C'\fR if
these do not match the default \f(CW\*(C`,\*(C'\fR and \f(CW\*(C`"\*(C'\fR.
.PP
When an error is found in the CSV, it is automatically reported (to STDERR).
The structure will store the error in \f(CW\*(C`$ss\->[0]{error}\*(C'\fR as anonymous
list returned by
\&\f(CW\*(C`$csv\->error_diag\*(C'\fR <https://metacpan.org/pod/Text::CSV_XS#error_diag>.
See Text::CSV_XS <https://metacpan.org/pod/Text::CSV_XS> for documentation.
.PP
.Vb 2
\& my $ss = ReadData ("bad.csv");
\& $ss\->[0]{error} and say $ss\->[0]{error}[1];
.Ve
.PP
As CSV has no sheet labels, the default label for a CSV sheet is its filename.
For CSV, this can be overruled using the \fIlabel\fR attribute:
.PP
.Vb 1
\& my $ss = Spreadsheet::Read\->new ("/some/place/test.csv", label => "Test");
.Ve
.SS "Cell Attributes"
.IX Xref "attr"
.IX Subsection "Cell Attributes"
If the constructor was called with \f(CW\*(C`attr\*(C'\fR having a true value,
.PP
.Vb 2
\& my $book = ReadData ("book.xls", attr => 1);
\& my $book = Spreadsheet::Read\->new ("book.xlsx", attr => 1);
.Ve
.PP
effort is made to analyze and store field attributes like this:
.PP
.Vb 10
\&    { label  => "Sheet 1",
\&      maxrow => 5,
\&      maxcol => 2,
\&      cell   => [ undef,
\&        [ undef, 1 ],
\&        [ undef, undef, undef, undef, undef, "Nugget" ],
\&        ],
\&      attr   => [ undef,
\&        [ undef, {
\&          type    => "numeric",
\&          fgcolor => "#ff0000",
\&          bgcolor => undef,
\&          font    => "Arial",
\&          size    => undef,
\&          format  => "## ##0.00",
\&          halign  => "right",
\&          valign  => "top",
\&          uline   => 0,
\&          bold    => 0,
\&          italic  => 0,
\&          wrap    => 0,
\&          merged  => 0,
\&          hidden  => 0,
\&          locked  => 0,
\&          enc     => "utf\-8",
\&          }, ],
\&        [ undef, undef, undef, undef, undef, {
\&          type    => "text",
\&          fgcolor => "#e2e2e2",
\&          bgcolor => undef,
\&          font    => "Letter Gothic",
\&          size    => 15,
\&          format  => undef,
\&          halign  => "left",
\&          valign  => "top",
\&          uline   => 0,
\&          bold    => 0,
\&          italic  => 0,
\&          wrap    => 0,
\&          merged  => 0,
\&          hidden  => 0,
\&          locked  => 0,
\&          enc     => "iso8859\-1",
\&          }, ],
\&        ],
\&      merged => [],
\&      A1     => 1,
\&      B5     => "Nugget",
\&      },
.Ve
.PP
The entries \f(CW\*(C`maxrow\*(C'\fR and \f(CW\*(C`maxcol\*(C'\fR are 1\-based.
.PP
This has now been partially implemented, mainly for Excel, as the other
parsers do not (yet) support all of that. YMMV.
.PP
If a cell itself is not hidden, but the parser holds the information that
either the row or the column (or both) the field is in is hidden, the flag
is inherited into the cell attributes.
.PP
You can get the attributes of a cell (as a hash\-ref) like this:
.PP
.Vb 3
\& my $attr = $book[1]{attr}[1][3];          # Direct structure
\& my $attr = $book\->sheet (1)\->attr (1, 3); # Same using OO
\& my $attr = $book\->sheet (1)\->attr ("A3"); # Same using OO
.Ve
.PP
To get to the \f(CW\*(C`font\*(C'\fR attribute, use any of these:
.PP
.Vb 3
\& my $font = $book[1]{attr}[1][3]{font};
\& my $font = $book\->sheet (1)\->attr (1, 3)\->{font};
\& my $font = $book\->sheet (1)\->attr ("A3")\->font;
.Ve
.PP
\fIMerged cells\fR
.IX Xref "merged"
.IX Subsection "Merged cells"
.PP
Note that only
Spreadsheet::ReadSXC <https://metacpan.org/release/Spreadsheet-ReadSXC>
documents the use of merged cells, and not in a way useful for the spreadsheet
consumer.
.PP
CSV does not support merged cells (though future implementations of CSV
for the web might).
.PP
The documentation of merged areas in
Spreadsheet::ParseExcel <https://metacpan.org/release/Spreadsheet-ParseExcel> and
Spreadsheet::ParseXLSX <https://metacpan.org/release/Spreadsheet-ParseXLSX> can
be found in
Spreadsheet::ParseExcel::Worksheet <https://metacpan.org/pod/Spreadsheet::ParseExcel::Worksheet>
and Spreadsheet::ParseExcel::Cell <https://metacpan.org/pod/Spreadsheet::ParseExcel::Cell>.
.PP
None of basic Spreadsheet::XLSX <https://metacpan.org/release/Spreadsheet-XLSX>,
Spreadsheet::ParseExcel <https://metacpan.org/release/Spreadsheet-ParseExcel>, and
Spreadsheet::ParseXLSX <https://metacpan.org/release/Spreadsheet-ParseXLSX> manual
pages mention merged cells at all.
.PP
This module just tries to return the information in a generic way.
.PP
Given this spreadsheet as an example
.PP
.Vb 1
\& merged.xlsx:
\&
\&     A     B     C
\&  +\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+
\& 1|     | foo       |
\&  +\-\-\-\-\-+           +
\& 2| bar |           |
\&  |     +\-\-\-\-\-+\-\-\-\-\-+
\& 3|     | urg | orc |
\&  +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+
.Ve
.PP
the information extracted from that undocumented information is
returned in the \f(CW\*(C`merged\*(C'\fR entry of the sheet\*(Aqs hash as a list of
top\-left, bottom\-right coordinate pars (col, row, col, row). For
given example, that would be:
.PP
.Vb 4
\& $ss\->{merged} = [
\&    [ 1, 2, 1, 3 ], # A2\-A3
\&    [ 2, 1, 3, 2 ], # B1\-C2
\&    ];
.Ve
.PP
To find the label of the top\-left cell in a merged area, use the
\&\f(CW\*(C`merged_from\*(C'\fR method.
.PP
.Vb 1
\& $ss\->merged_from ("C2"); # will return "B1"
.Ve
.PP
When the attributes are also enabled, there is some merge information
copied directly from the cell information, but again, that stems from
code analysis and not from documentation:
.PP
.Vb 9
\& my $ss = ReadData ("merged.xlsx", attr => 1)\->[1];
\& foreach my $row (1 .. $ss\->{maxrow}) {
\&     foreach my $col (1 .. $ss\->{maxcol}) {
\&         my $cell = cr2cell ($col, $row);
\&         printf "%s %\-3s %s  ", $cell, $ss\->{$cell},
\&             $ss\->{attr}[$col][$row]{merged};
\&         }
\&     print "\en";
\&     }
\&
\& A1     0  B1 foo 1  C1     1
\& A2 bar 1  B2     1  C2     1
\& A3     1  B3 urg 0  C3 orc 0
.Ve
.PP
In this example, there is no way to see if \f(CW\*(C`B2\*(C'\fR is merged to \f(CW\*(C`A2\*(C'\fR or
to \f(CW\*(C`B1\*(C'\fR without analyzing all surrounding cells. This could as well
mean \f(CW\*(C`A2:A3\*(C'\fR, \f(CW\*(C`B1:C1\*(C'\fR, \f(CW\*(C`B2:C2\*(C'\fR, as \f(CW\*(C`A2:A3\*(C'\fR, \f(CW\*(C`B1:B2\*(C'\fR, \f(CW\*(C`C1:C2\*(C'\fR, as
\&\f(CW\*(C`A2:A3\*(C'\fR, \f(CW\*(C`B1:C2\*(C'\fR.
.PP
Use the \f(CW\*(C`merged\*(C'\fR entry described above to find out what
fields are merged to what other fields or use \f(CW\*(C`merge\*(C'\fR:
.PP
.Vb 9
\& my $ss = ReadData ("merged.xlsx", attr => 1, merge => 1)\->[1];
\& foreach my $row (1 .. $ss\->{maxrow}) {
\&     foreach my $col (1 .. $ss\->{maxcol}) {
\&         my $cell = cr2cell ($col, $row);
\&         printf "%s %\-3s %s  ", $cell, $ss\->{$cell},
\&             $ss\->{attr}[$col][$row]{merged};
\&         }
\&     print "\en";
\&     }
\&
\& A1     0   B1 foo B1  C1 foo B1
\& A2 bar A2  B2 foo B1  C2 foo B1
\& A3 bar A2  B3 urg 0   C3 orc 0
.Ve
.SS "Streams from web\-resources"
.IX Subsection "Streams from web-resources"
If you want to stream a web\-resource, and the underlying parser supports it,
you could use a helper function like this (thanks Corion):
.PP
.Vb 2
\& use HTTP::Tiny;
\& use Spreadsheet::Read;
\&
\& # Fetch data and return a filehandle to that data
\& sub fh_from_url {
\&     my $url = shift;
\&     my $ua  = HTTP::Tiny\->new;
\&     my $res = $ua\->get ($url);
\&     open my $fh, "<", \e$res\->{content};
\&     return $fh
\&     } # fh_from_url
\&
\& my $fh = fh_from_url ("http://example.com/example.csv");
\& my $sheet = Spreadsheet::Read\->new ($fh, parser => "csv");
.Ve
.SH TOOLS
.IX Header "TOOLS"
This modules comes with a few tools that perform tasks from the FAQ, like
"How do I select only column D through F from sheet 2 into a CSV file?"
.PP
If the module was installed without the tools, you can find them here:
  https://github.com/Tux/Spreadsheet\-Read/tree/master/scripts
.ie n .SS """xlscat"""
.el .SS \f(CWxlscat\fP
.IX Subsection "xlscat"
Show (parts of) a spreadsheet in plain text, CSV, or HTML
.PP
.Vb 10
\& usage: xlscat   [\-s <sep>] [\-L] [\-n] [\-A] [\-u] [Selection] file.xls
\&                 [\-c | \-m]                 [\-u] [Selection] file.xls
\&                  \-i                            [\-S sheets] file.xls
\&     Generic options:
\&        \-v[#]       Set verbose level (xlscat/xlsgrep)
\&        \-d[#]       Set debug   level (Spreadsheet::Read)
\&        \-\-list      Show supported spreadsheet formats and exit
\&        \-u          Use unformatted values
\&        \-\-strip[=#] Strip leading and/or traing spaces of all cells
\&                    # & 01 = leading, # & 02 = trailing, 3 = default
\&        \-\-clip=#    Clip cells to max length #
\&        \-\-noclip    Do not strip empty sheets and
\&                    trailing empty rows and columns
\&        \-\-no\-empty  Skip empty rows
\&         \-\-no\-nl[=R] Replace all newlines in cells with R (default space)
\&        \-e <enc>    Set encoding for input and output
\&        \-b <enc>    Set encoding for input
\&        \-a <enc>    Set encoding for output
\&        \-U          Set encoding for output to utf\-8 (short for \-a utf\-8)
\&     Input CSV:
\&        \-\-in\-sep=c  Set input sep_char for CSV (c can be \*(AqTAB\*(Aq)
\&     Input XLS:
\&        \-\-dtfmt=fmt Specify the default date format to replace \*(Aqm\-d\-yy\*(Aq
\&                    the default replacement is \*(Aqyyyy\-mm\-dd\*(Aq
\&        \-\-passwd=pw Specify the password for workbook
\&                    if pw = \-, read password from keyboard
\&        \-\-formulas  Show the formula instead of the value
\&     Output Text (default):
\&        \-s <sep>    Use separator <sep>. Default \*(Aq|\*(Aq, \en allowed
\&                    Overrules \*(Aq,\*(Aq when used with \-\-csv
\&        \-L          Line up the columns
\&        \-B  \-\-box   Like \-L but also add outer frame
\&        \-n [skip]   Number lines (prefix with column number)
\&                    optionally skip <skip> (header) lines
\&        \-A          Show field attributes in ANSI escapes
\&        \-h[#]       Show # header lines
\&        \-D          Dump each record with Data::Peek or Data::Dumper
\&         \-\-hash     Like \-D but as hash with first row as keys
\&     Output CSV:
\&        \-c          Output CSV, separator = \*(Aq,\*(Aq
\&        \-m          Output CSV, separator = \*(Aq;\*(Aq
\&     Output Index only:
\&        \-i          Show sheet names and size only
\&     Output HTML:
\&        \-H          Output HTML
\&     Selection:
\&        \-S <sheets> Only print sheets <sheets>. \*(Aqall\*(Aq is a valid set
\&                    Default only prints the first sheet
\&        \-R <rows>   Only print rows    <rows>. Default is \*(Aqall\*(Aq
\&                    Ranges and lists supported as 2,4\-7,8\-
\&                    Trailing \- is to end of data
\&                    Negative rows count from tail \-8\-\-2 is allowed
\&         \-\-head[=n] Alias for \-R1..n   where n defaults to 10
\&         \-\-tail[=n] Alias for \-R\-n\-    where n defaults to 10
\&        \-C <cols>   Only print columns <cols>. Default is \*(Aqall\*(Aq
\&        \-F <flds>   Only fields <flds> e.g. \-FA3,B16
\&     Ordering (column numbers in result set *after* selection):
\&        \-\-sort=spec Sort output (e.g. \-\-sort=3,2r,5n,1rn+2)
\&                    +#   \- first # lines do not sort (header)
\&                    #    \- order on column # lexical ascending
\&                    #n   \- order on column # numeric ascending
\&                    #r   \- order on column # lexical descending
\&                    #rn  \- order on column # numeric descending
\&
\& Examples:
\&     xlscat   \-i foo.xls
\&     xlscat   \-\-in\-sep=: \-\-sort=3n \-L /etc/passwd
\&     xlsgrep  pattern file.ods
.Ve
.ie n .SS """xlsgrep"""
.el .SS \f(CWxlsgrep\fP
.IX Subsection "xlsgrep"
Show (parts of) a spreadsheet that match a pattern in plain text, CSV, or HTML
.PP
.Vb 10
\& usage: xlsgrep  [\-s <sep>] [\-L] [\-n] [\-A] [\-u] [Selection] pattern file.xls
\&                 [\-c | \-m]                 [\-u] [Selection] pattern file.xls
\&                  \-i                            [\-S sheets] pattern file.xls
\&     Generic options:
\&        \-v[#]       Set verbose level (xlscat/xlsgrep)
\&        \-d[#]       Set debug   level (Spreadsheet::Read)
\&        \-\-list      Show supported spreadsheet formats and exit
\&        \-u          Use unformatted values
\&        \-\-strip[=#] Strip leading and/or traing spaces of all cells
\&                    # & 01 = leading, # & 02 = trailing, 3 = default
\&        \-\-clip=#    Clip cells to max length #
\&        \-\-noclip    Do not strip empty sheets and
\&                    trailing empty rows and columns
\&        \-\-no\-empty  Skip empty rows
\&         \-\-no\-nl[=R] Replace all newlines in cells with R (default space)
\&        \-e <enc>    Set encoding for input and output
\&        \-b <enc>    Set encoding for input
\&        \-a <enc>    Set encoding for output
\&        \-U          Set encoding for output to utf\-8 (short for \-a utf\-8)
\&     Input CSV:
\&        \-\-in\-sep=c  Set input sep_char for CSV (c can be \*(AqTAB\*(Aq)
\&     Input XLS:
\&        \-\-dtfmt=fmt Specify the default date format to replace \*(Aqm\-d\-yy\*(Aq
\&                    the default replacement is \*(Aqyyyy\-mm\-dd\*(Aq
\&        \-\-passwd=pw Specify the password for workbook
\&                    if pw = \-, read password from keyboard
\&        \-\-formulas  Show the formula instead of the value
\&     Output Text (default):
\&        \-s <sep>    Use separator <sep>. Default \*(Aq|\*(Aq, \en allowed
\&                    Overrules \*(Aq,\*(Aq when used with \-\-csv
\&        \-L          Line up the columns
\&        \-B  \-\-box   Like \-L but also add outer frame
\&        \-n [skip]   Number lines (prefix with column number)
\&                    optionally skip <skip> (header) lines
\&        \-A          Show field attributes in ANSI escapes
\&        \-h[#]       Show # header lines
\&        \-D          Dump each record with Data::Peek or Data::Dumper
\&         \-\-hash     Like \-D but as hash with first row as keys
\&     Output CSV:
\&        \-c          Output CSV, separator = \*(Aq,\*(Aq
\&        \-m          Output CSV, separator = \*(Aq;\*(Aq
\&     Grep options:
\&        \-i          Ignore case
\&        \-w          Match whole words only
\&     Output HTML:
\&        \-H          Output HTML
\&     Selection:
\&        \-S <sheets> Only print sheets <sheets>. \*(Aqall\*(Aq is a valid set
\&                    Default only prints the first sheet
\&        \-R <rows>   Only print rows    <rows>. Default is \*(Aqall\*(Aq
\&                    Ranges and lists supported as 2,4\-7,8\-
\&                    Trailing \- is to end of data
\&                    Negative rows count from tail \-8\-\-2 is allowed
\&         \-\-head[=n] Alias for \-R1..n   where n defaults to 10
\&         \-\-tail[=n] Alias for \-R\-n\-    where n defaults to 10
\&        \-C <cols>   Only print columns <cols>. Default is \*(Aqall\*(Aq
\&        \-F <flds>   Only fields <flds> e.g. \-FA3,B16
\&     Ordering (column numbers in result set *after* selection):
\&        \-\-sort=spec Sort output (e.g. \-\-sort=3,2r,5n,1rn+2)
\&                    +#   \- first # lines do not sort (header)
\&                    #    \- order on column # lexical ascending
\&                    #n   \- order on column # numeric ascending
\&                    #r   \- order on column # lexical descending
\&                    #rn  \- order on column # numeric descending
\&
\& Examples:
\&     xlscat   \-i foo.xls
\&     xlscat   \-\-in\-sep=: \-\-sort=3n \-L /etc/passwd
\&     xlsgrep  pattern file.ods
.Ve
.ie n .SS """xlsx2csv"""
.el .SS \f(CWxlsx2csv\fP
.IX Subsection "xlsx2csv"
Convert a spreadsheet to CSV. This is just a small wrapper over \f(CW\*(C`xlscat\*(C'\fR.
.PP
.Vb 12
\& usage: xlsx2csv [\-A [\-N | \-J c] | \-o file.csv] [\-s sep] [\-f] [\-i] file.xls
\&        xlsx2csv \-\-help | \-\-man | \-\-info
\&           \-\-list    List supported spreadsheet formats and exit
\&     \-A    \-\-all     Export all sheets      (filename\-sheetname.csv)
\&     \-N    \-\-no\-pfx  No filene prefix on \-A (sheetname.csv)
\&     \-Z    \-\-zip     Convert sheets to CSV\*(Aqs in ZIP
\&     \-J s  \-\-join=s  Use s to join filename\-sheetname (\-)
\&     \-o f  \-\-out=f   Set output filename
\&     \-i f  \-\-in=f    Set input  filename
\&     \-f    \-\-force   Force overwrite output if exists
\&     \-s s  \-\-sep=s   Set CSV separator character
\& Unless \-A is used, all other options are passed on to xlscat
.Ve
.ie n .SS """xls2csv"""
.el .SS \f(CWxls2csv\fP
.IX Subsection "xls2csv"
Convert a spreadsheet to CSV. This is identical to \f(CW\*(C`xlsx2csv\*(C'\fR
.ie n .SS """ss2tk"""
.el .SS \f(CWss2tk\fP
.IX Subsection "ss2tk"
Show a spreadsheet in a perl/Tk spreadsheet widget
.PP
.Vb 7
\& usage: ss2tk [options] [X11 options] file.xls [<pattern>]
\&        \-w <width> use <width> as column width
\&        \-L         Add spreadsheet tags to top (A, B, ..Z, AB, ...)
\&                   and left (1, 2, ...)
\&        \-\-fs[=7]   Set font size (default 7 if no value)
\&        \-\-fn=name  Set font Face name (default is DejaVu Sans Mono
\&                   if font size is given
.Ve
.ie n .SS """ssdiff"""
.el .SS \f(CWssdiff\fP
.IX Subsection "ssdiff"
Show the differences between two spreadsheets.
.PP
.Vb 1
\& usage: ssdiff [\-\-verbose[=1]] file.xls file.xlsx
.Ve
.SH Vulnerabilities
.IX Header "Vulnerabilities"
As this is just a wrapper over the actual parsers, it cannot vouch for
vulnerabilities in these parsers.  We try to keep up with the CVE\*(Aqs as
published, and check for weaknesses. For a more thorough report see
this security\-posting <https://security.metacpan.org/2024/02/10/vulnerable-spreadsheet-parsing-modules.html>.
.SH TODO
.IX Header "TODO"
.IP Options 4
.IX Item "Options"
.RS 4
.PD 0
.IP "Module Options" 2
.IX Item "Module Options"
.PD
New Spreadsheet::Read options are bound to happen. I\*(Aqm thinking of an
option that disables the reading of the data entirely to speed up an
index request (how many sheets/fields/columns). See \f(CW\*(C`xlscat \-i\*(C'\fR.
.IP "Parser options" 2
.IX Item "Parser options"
Try to transparently support as many options as the encapsulated modules
support regarding (un)formatted values, (date) formats, hidden columns
rows or fields etc. These could be implemented like \f(CW\*(C`attr\*(C'\fR above but
names \f(CW\*(C`meta\*(C'\fR, or just be new values in the \f(CW\*(C`attr\*(C'\fR hashes.
.RE
.RS 4
.RE
.IP "Other parsers" 4
.IX Item "Other parsers"
Add support for new(er) parsers for already supported formats, like
.RS 4
.IP Data::XLSX::Parser 2
.IX Item "Data::XLSX::Parser"
Data::XLSX::Parser provides faster way to parse Microsoft Excel\*(Aqs .xlsx
files. The implementation of this module is highly inspired from Python\*(Aqs
FastXLSX library.
.Sp
This is SAX based parser, so you can parse very large XLSX file with
lower memory usage.
.Sp
Last commit 2021\-02\-16, so I will take PR\*(Aqs but won\*(Aqt do it myself as
there seems to be little gain in supporting this.
.RE
.RS 4
.RE
.IP "Other spreadsheet formats" 4
.IX Item "Other spreadsheet formats"
I consider adding any spreadsheet interface that offers a usable API.
.Sp
Under investigation:
.RS 4
.IP "Kspread (.ksp)" 2
.IX Item "Kspread (.ksp)"
Now knows as Calligra Sheets.
.Sp
I have seen no existing CPAN module yet.
.Sp
It is XML in ZIP
.RE
.RS 4
.RE
.IP "Alternative parsers for existing formats" 4
.IX Item "Alternative parsers for existing formats"
As long as the alternative has a good reason for its existence, and the
API of that parser reasonable fits in my approach, I will consider to
implement the glue layer, or apply patches to do so as long as these
match what \fICONTRIBUTING.md\fR describes.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Text::CSV_XS, Text::CSV_PP" 2
.IX Item "Text::CSV_XS, Text::CSV_PP"
See Text::CSV_XS <https://metacpan.org/release/Text-CSV_XS> ,
Text::CSV_PP <https://metacpan.org/release/Text-CSV> , and
Text::CSV <https://metacpan.org/release/Text-CSV> documentation.
.Sp
Text::CSV <https://metacpan.org/release/Text-CSV> is a wrapper over Text::CSV_XS (the fast XS version) and/or
Text::CSV_PP <https://metacpan.org/release/Text-CSV> (the pure perl version).
.IP Spreadsheet::ParseExcel 2
.IX Item "Spreadsheet::ParseExcel"
Spreadsheet::ParseExcel <https://metacpan.org/release/Spreadsheet-ParseExcel> is
the best parser for old\-style Microsoft Excel (.xls) files.
Most recent commit was Dec 2023. Please use version 0.66 or higher to prevent
possible memory bombs.
.IP Spreadsheet::ParseXLSX 2
.IX Item "Spreadsheet::ParseXLSX"
Spreadsheet::ParseXLSX <https://metacpan.org/release/Spreadsheet-ParseXLSX> is
like Spreadsheet::ParseExcel <https://metacpan.org/release/Spreadsheet-ParseExcel>,
but for new Microsoft Excel 2007+ files (.xlsx). They have the same API.
.Sp
This module uses XML::Twig <https://metacpan.org/release/XML-Twig> to parse the
internal XML. Most recent commit was in Dec 2023. Please use version 0.29 or
higher to prevent possible memory bombs.
.IP Spreadsheet::XLSX 2
.IX Item "Spreadsheet::XLSX"
See Spreadsheet::XLSX <https://metacpan.org/release/Spreadsheet-XLSX>
documentation.
.Sp
This module is dead and deprecated. It is \fBbuggy and unmaintained\fR (Most recent
commit was Oct 2014).  \fIPlease\fR use
Spreadsheet::ParseXLSX <https://metacpan.org/release/Spreadsheet-ParseXLSX>
instead.
.IP Excel::ValueReader::XLSX 2
.IX Item "Excel::ValueReader::XLSX"
See Excel::ValueReader::XLSX <https://metacpan.org/release/Excel-ValueReader-XLSX>
documentation.
.Sp
This module aims at speed\-reading ignoring all attributes and formatting.
.Sp
Using this backend does not, and will not, support parsing strings, string\-refs,
or globs. Only filenames and file handles are supported.
.IP Spreadsheet::ParseODS 2
.IX Item "Spreadsheet::ParseODS"
Spreadsheet::ParseODS <https://metacpan.org/pod/Spreadsheet::ParseODS> is a
parser for OpenOffice/LibreOffice (.sxc and .ods) spreadsheet files. It is the
successor of  Spreadsheet::ReadSXC <https://metacpan.org/release/Spreadsheet-ReadSXC>.
.IP Spreadsheet::ReadSXC 2
.IX Item "Spreadsheet::ReadSXC"
Spreadsheet::ReadSXC <https://metacpan.org/release/Spreadsheet-ReadSXC> is a
parser for OpenOffice/LibreOffice (.sxc and .ods) spreadsheet files.
.IP Spreadsheet::ReadGnumeric 2
.IX Item "Spreadsheet::ReadGnumeric"
Spreadsheet::ReadGnumeric <https://metacpan.org/release/Spreadsheet-ReadGnumeric>
is a parser for Gnumeric <http://www.gnumeric.org/> (.gnumeric) spreadsheet
files.
.IP Spreadsheet::BasicRead 2
.IX Item "Spreadsheet::BasicRead"
See Spreadsheet::BasicRead <https://metacpan.org/release/Spreadsheet-BasicRead>
for xlscat\-like functionality (Excel only)
.IP Spreadsheet::ConvertAA 2
.IX Item "Spreadsheet::ConvertAA"
See Spreadsheet::ConvertAA <https://metacpan.org/release/Spreadsheet-ConvertAA>
for an alternative set of "cell2cr"/"cr2cell" pair.
.IP Spreadsheet::Perl 2
.IX Item "Spreadsheet::Perl"
Spreadsheet::Perl <https://metacpan.org/release/Spreadsheet-Perl> offers a Pure
Perl implementation of a spreadsheet engine.  Users that want this format to be
supported in Spreadsheet::Read are hereby motivated to offer patches. It is
not high on my TODO\-list.
.IP Spreadsheet::CSV 2
.IX Item "Spreadsheet::CSV"
Spreadsheet::CSV <https://metacpan.org/release/Spreadsheet-CSV> offers the
interesting approach of seeing all supported spreadsheet formats as if it were
CSV, mimicking the Text::CSV_XS <https://metacpan.org/release/Text-CSV_XS>
interface.
.IP xls2csv 2
.IX Item "xls2csv"
xls2csv <https://github.com/Tux/Spreadsheet-Read/blob/master/scripts/xls2csv>
offers an alternative for my \f(CW\*(C`xlscat \-c\*(C'\fR, in the xls2csv tool, but this tool
focuses on character encoding transparency, and requires some other modules.
.SH AUTHOR
.IX Header "AUTHOR"
H.Merijn Brand <perl5@tux.freedom.nl>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005\-2025 H.Merijn Brand
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
